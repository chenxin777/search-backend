{
  "code": 0,
  "data": {
    "records": [
      {
        "id": "1794289385455558658",
        "title": "泪目！网络连接中断的原因，终于找到了！",
        "description": null,
        "content": "朋友们，出大事了！\n\n不知道多少朋友玩过 DNF 这个游戏，这个我从小学玩到大学的 “破” 游戏，昨天竟然出手游了！\n\n我都忘了自己曾几何时预约过这个手游通知，昨天给我发了条通知信息说游戏已开服。\n\n老玩家直接泪目了啊：时空之门，开！\n\n好心动啊，然而我心中有一个声音告诉自己：不能下！不能下！不能下！\n\n因为根据我自己小时候凌晨偷摸爬起来玩游戏冲级的沉迷经历，一旦我玩了，公司基本就没救了，本来就忙的一批，怎能让一个小 “破” 游戏，影响了我的大事！\n\n![玩笑话](https://pic.yupi.icu/1/image-20240522121041814.png)\n\n言归正传，无论大家有没有玩过这个，我相信大家都有过玩游戏或工作时 “网络连接中断” 的经历吧。\n\n我小时候还真就遇到过刚刚爆了好装备，就网络连接中断的情况，当时都给我气哭了，心里把策划的祖宗十八代都问候了一遍。\n\n![](https://pic.yupi.icu/1/kabqNeboEkvnoCq.jpg)\n\n但做了程序员之后，我现在已经能够理解为什么会出现网络连接中断、服务器挤不进去、游戏延迟的情况了。\n\n这篇文章就从技术的角度出发，给大家科普一些网络方面的概念，也许能帮你打游戏更快哦~\n\n\n\n## 网络小知识\n\n### 一、网络连接中断的常见原因\n\n#### 1、网络延迟大或不稳定\n\n延迟：指数据包从发送端到接收端所需的时间。这个概念在游戏中，尤其是 FPS 第一人称射击游戏和 RTS 实施策略游戏中尤为重要。因为延迟会导致操作反馈的滞后，玩家可能会感觉到游戏操作不流畅，甚至出现瞬间卡顿。\n\n抖动：指数据包传输时间的变化。当抖动过大时，会导致数据包到达时间不一致，从而影响游戏体验。典型的现象就是，玩家可能会看到游戏角色突然移动到另一个位置，实现 “瞬移”。\n\n丢包：在数据传输过程中，某些数据包丢失，未能成功到达目的地。丢包会导致游戏中的信息不完整、出现卡顿、画面跳动等问题。丢包率较高时，游戏基本就没法玩了，持续丢包就有可能导致服务器断开连接。\n\n小时候我家里网络差，最心酸的事情是因为网络延迟跳过自己的行动回合、或者因为抖动和丢包导致怪物满屏乱飘，当时戏称这些是 “游戏特性”。\n\n\n\n#### 2、带宽不足\n\n即使不是程序员，我相信大家对带宽这个概念也并不陌生。带宽是指单位时间内可以传输的数据量，它很大程度上决定了网速的快慢。\n\n带宽分为上行带宽和下行带宽。上行带宽指的是从客户端（如家庭网络）向服务器发送数据的速度，理解为上传；下行带宽则是从服务器向客户端传输数据的速度，理解为下载。\n\n当多个设备同时使用网络时，如果带宽不足，尤其是上行带宽不足，就会导致网络拥堵，影响游戏数据的传输速度。\n\n需要注意的是，即使你家的网络速度很快，游戏体验也不一定会很好。因为网络通信是客户端和服务端双向的。如果游戏公司的服务器本身性能较差、带宽较小，即使你的带宽很高，网络传输的性能也不会很好，进而影响游戏体验。\n\n![](https://pic.yupi.icu/1/image-20240522124059251.png)\n\n\n\n#### 3、服务端问题\n\n前面也提到了，除了自己的网络外，服务端也是影响网络连接和速度的决定性因素。比如游戏开服或秒杀活动上线时，瞬时间会有大量的流量涌入服务器，如果服务器没有做好流量预估、扩容和相应的处理措施，很可能出现网络拥塞、服务器过载等问题，导致玩家的网络连接不稳定。\n\n为了避免网络拥塞和服务器过载，通常每个服务器都会设置一个允许连接的最大用户数。所以才会出现下图的名场面：\n\n![](https://pic.yupi.icu/1/image-20240522124705992.png)\n\n此外，一般游戏更新维护的时间都在凌晨或者玩家访问量不大的时候；而且为了保证游戏数据不出问题、更好地进行测试，很多游戏会选择停机维护。\n\n哦对了，如果游戏服务器不幸被 DDoS 攻击，也有可能会造成网络连接中断。\n\n\n\n#### 4、其他原因\n\n除了上面几点我们最明显能感受到的网络问题外，还有一些我们可能感受不到的影响网络的因素，比如路由器配置和硬件问题、邻近 Wi-Fi 网络干扰等。\n\n\n\n### 二、网络优化小建议\n\n分享了一些网络知识后，再聊一聊可行的网络优化小建议吧，我相信很多同学都实践过。\n\n1）尽量使用有线连接，会比无线连接更稳定，减少干扰。\n\n2）选择一个覆盖面广的路由器，可以定期检查和更新固件，提升设备性能和稳定性。\n\n3）除了升级自家带宽外，平时可以多关注网络带宽的使用占比。因为现在很多应用都会在后台默默传输一些数据，积少成多。追求极致性能的话，可以用一些网络监控工具来分析带宽占用，在打游戏时关闭掉一些软件。\n\n有位大佬开源了一款免费的网络监控工具 TrafficMonitor，分享给大家：https://github.com/zhongyang219/TrafficMonitor\n\n![](https://pic.yupi.icu/1/main1.png)\n\n4）选择合适的游戏服务器。这点其实很重要，建议选择离自己地理位置较近的服务器。我小时候不懂，家在江苏，非要去选个什么广东的游戏大区。\n\n5）使用专线网络或游戏加速器。原理就是让工具来帮我们选择更合适的服务器节点、并且优化数据的传输路径。但是这玩意我小时候打游戏的时候就不爱用，免费的没啥效果，收费的又搞不起。\n\n6）调整路由器的 QoS 设置。QoS（服务质量）是在网络上为不同应用程序分配带宽的技术，可以优先分配游戏所需的带宽，尽量保证游戏数据包的通信质量。\n\n\n\n## 最后\n\n除了上面这些知识点外，其实我自己脑洞挺大的，还想了很多关于 “网络连接中断” 的猜想。比如写下这样一段代码，吸引用户充值：\n\n```java\nif (用户 A 爆了装备 1) {\n  if (装备 1 是稀有装备) {\n    if (用户没充值) {\n      // 强行中断网络连接\n      connect.close()\n    }\n  }\n}\n```\n\n或者这样一段代码，让会员用户体验拉满！\n\n```java\nif (服务器人数已满) {\n  if (用户 A 是普通用户) {\n\t\t弹窗提示(\"服务器人数已满\")\n  } else if (用户 A 是会员) {\n    // 允许进入服务器\n    connect.start()\n    // 让一个普通用户网络连接中断\n    userBconnect.close()\n  }\n}\n```\n\n仅供娱乐，如果你是一家游戏公司的开发和策划，请别这么干谢谢！\n\n\n\n可访问我的 Github：https://github.com/liyupi ，了解更多技术和项目内容。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1601072287388278786/pDY2eMge-0525.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 2,
        "thumbNum": 0,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "editTime": "2024-05-25 16:48:20",
        "createTime": "2024-05-25 16:48:20",
        "updateTime": "2024-05-25 18:13:04",
        "accessScope": 0,
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3345,
          "scoreLevel": 7,
          "coin": 170,
          "followeeNum": 1568,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2287-05-20 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-05-25 16:14:58"
        },
        "tags": [
          "文章",
          "后端",
          "腾讯"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      },
      {
        "id": "1793966114007547905",
        "title": "《软件测试》学习笔记",
        "description": "个人测试理论学习记录",
        "content": "语雀学习笔记：\nhttps://www.yuque.com/yuqueyonghuvginhi/fcp06n/viuls02k6sr1y7o0?singleDoc#",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 9,
        "thumbNum": 1,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1621433932878725122",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "editTime": "2024-05-24 19:23:46",
        "createTime": "2024-05-24 19:23:46",
        "updateTime": "2024-05-25 17:28:45",
        "accessScope": 0,
        "user": {
          "id": "1621433932878725122",
          "planetCode": "17375",
          "userName": "Asha",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1621433932878725122/CHvfFwr2-IMG_3459.jpeg",
          "gender": 1,
          "userProfile": null,
          "userRole": "vip",
          "interests": [],
          "place": "河南省郑州市",
          "birthday": "2002-12-19",
          "school": "河南农业大学",
          "major": "数据科学与大数据技术",
          "education": "一本",
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": "恒生电子",
          "job": "测试",
          "workYear": null,
          "direction": "测试",
          "goal": "校招",
          "github": null,
          "blog": null,
          "score": 0,
          "scoreLevel": 1,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-01-30 10:16:07",
          "lastLoginTime": null,
          "createTime": "2023-02-03 17:02:29",
          "updateTime": "2024-05-23 20:01:44"
        },
        "tags": [
          "书籍",
          "测试",
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      },
      {
        "id": "1793521144500027393",
        "title": "\uD83D\uDE30我被恐吓了，对方扬言要压测我的网站",
        "description": "大家好我是聪，昨天真是水逆，在技术群里交流问题，竟然被人身攻击了！骂的话太难听具体就不加讨论了，人身攻击我可以接受，我接受不了他竟然说要刷我接口！！！！这下激发我的灵感来写一篇如何抵御黑子的压测攻击。",
        "content": "# 如何应对黑子的恐吓\n\n大家好我是聪，昨天真是水逆，在技术群里交流问题，竟然被人身攻击了！骂的话太难听具体就不加讨论了，人身攻击我可以接受，我接受不了他竟然说要刷我接口！！！！这下激发我的灵感来写一篇如何抵御黑子的压测攻击，还真得要谢谢他。\n\n\n![image-20240523081706355.png](https://pic.code-nav.cn/post_picture/1612254411675926529/lXYXbZke-image-20240523081706355.png)\n\n\uD83D\uDD25本次的自动加入黑名单拦截代码已经上传到短链狗，想学习如何生成一个短链可以去编程导航网站上查看喔，项目地址：https://www.code-nav.cn/course/1792807139336581122\n\n## 思维发散\n\n如果有人要攻击我的网站，我应该从哪些方面开始预防呢，我想到了以下几点，如何还有其他的思路欢迎大家补充：\n\n1. 从前端开始预防！\n\n   聪 A\uD83E\uDDD1：确实是一种办法，给前端 ➕ 验证码、短信验证，或者加上谷歌认证（用户说：我谢谢你哈，消防栓）。\n\n   聪 B\uD83E\uDDD1：再次思考下还是算了，这次不想动我的前端加上如何短信验证还消耗我的\uD83D\uDCB4，本来就是一个练手项目，打住❌。\n\n2. 人工干预！\n\n   聪 A\uD83E\uDDD1：哇！人工干预很累的欸，拜托。\n\n   聪 B\uD83E\uDDD1：那如果是定时人工检查进行干预处理，辅助其他检测手段呢，是不是感觉还行！\n\n3. 使用网关给他预防！\n\n   聪 A\uD83E\uDDD1：网关！好像听起来不错。\n\n   聪 B\uD83E\uDDD1：不行！我项目都没有网关，单单为了黑子增加一个网关，否决❌。\n\n4. 日志监控！\n\n   聪 A\uD83E\uDDD1：日志监控好像还不错欸，可以让系统日志的输出到时候统一监控，然后发短信告诉我们。\n\n   聪 B\uD83E\uDDD1：日志监控确实可以，发短信还是算了，拒绝一切花销哈❌。\n\n5. 我想到了！后端 AOP 拦截访问限流，通过自动检测将 IP + 用户ID 加入黑名单，让黑子无所遁形。\n\n   聪 A\uD83E\uDDD1：我觉得可以我们来试试？\n\n   聪 B\uD83E\uDDD1：还等什么！来试试吧！\n\n## 功能实现\n\n### 设置 AOP 注解\n\n1）获取拦截对象的标识，这个标识可以是用户 ID 或者是其他。\n\n2）限制频率。举个例子：如果每秒超过 10 次就直接给他禁止访问 1 分钟或者 5 分钟。\n\n3）加入黑名单。举个例子：当他多次触发禁止访问机制，就证明他还不死心还在刷，直接给他加入黑名单，可以是永久黑名单或者 1 天就又给他放出来。\n\n4）获取后面回调的方法，会用反射来实现接口的调用。\n\n有了以上几点属性，那么注解设置如下：\n\n```java\n/**\n * 黑名单拦截器\n *\n * @author cong\n * @date 2024/05/23\n */\n@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface BlacklistInterceptor {\n\n    /**\n     * 拦截字段的标识符\n     *\n     * @return {@link String }\n     */\n    String key() default \"default\";;\n\n    /**\n     * 频率限制 每秒请求次数\n     *\n     * @return double\n     */\n    double rageLimit() default 10;\n\n    /**\n     * 保护限制 命中频率次数后触发保护，默认触发限制就保护进入黑名单\n     *\n     * @return int\n     */\n    int protectLimit() default 1;\n\n    /**\n     * 回调方法\n     *\n     * @return {@link String }\n     */\n    String fallbackMethod();\n}\n```\n\n### 设置切面具体实现\n\n```java\n@Aspect\n@Component\n@Slf4j\npublic class RageLimitInterceptor {\n    private final Redisson redisson;\n\n    private RMapCache<String, Long> blacklist;\n    // 用来存储用户ID与对应的RateLimiter对象\n    private final Cache<String, RRateLimiter> userRateLimiters = CacheBuilder.newBuilder()\n            .expireAfterWrite(1, TimeUnit.MINUTES)\n            .build();\n\n    public RageLimitInterceptor(Redisson redisson) {\n        this.redisson = redisson;\n        if (redisson != null) {\n            log.info(\"Redisson object is not null, using Redisson...\");\n            // 使用 Redisson 对象执行相关操作\n            // 个人限频黑名单24h\n            blacklist = redisson.getMapCache(\"blacklist\");\n            blacklist.expire(24, TimeUnit.HOURS);// 设置过期时间\n        } else {\n            log.error(\"Redisson object is null!\");\n        }\n    }\n\n\n    @Pointcut(\"@annotation(com.cong.shortlink.annotation.BlacklistInterceptor)\")\n    public void aopPoint() {\n    }\n\n    @Around(\"aopPoint() && @annotation(blacklistInterceptor)\")\n    public Object doRouter(ProceedingJoinPoint jp, BlacklistInterceptor blacklistInterceptor) throws Throwable {\n        String key = blacklistInterceptor.key();\n\n        // 获取请求路径\n        RequestAttributes requestAttributes = RequestContextHolder.currentRequestAttributes();\n        HttpServletRequest httpServletRequest = ((ServletRequestAttributes) requestAttributes).getRequest();\n        //获取 IP\n        String remoteHost = httpServletRequest.getRemoteHost();\n        if (StringUtils.isBlank(key)) {\n            throw new BusinessException(ErrorCode.NO_AUTH_ERROR, \"拦截的 key 不能为空\");\n        }\n        // 获取拦截字段\n        String keyAttr;\n        if (key.equals(\"default\")) {\n            keyAttr = \"SystemUid\" + StpUtil.getLoginId().toString();\n        } else {\n            keyAttr = getAttrValue(key, jp.getArgs());\n        }\n\n        log.info(\"aop attr {}\", keyAttr);\n\n        // 黑名单拦截\n        if (blacklistInterceptor.protectLimit() != 0 && null != blacklist.getOrDefault(keyAttr, null) && (blacklist.getOrDefault(keyAttr, 0L) > blacklistInterceptor.protectLimit()\n                ||blacklist.getOrDefault(remoteHost, 0L) > blacklistInterceptor.protectLimit())) {\n            log.info(\"有小黑子被我抓住了！给他 24 小时封禁套餐吧：{}\", keyAttr);\n            return fallbackMethodResult(jp, blacklistInterceptor.fallbackMethod());\n        }\n\n        // 获取限流\n        RRateLimiter rateLimiter;\n        if (!userRateLimiters.asMap().containsKey(keyAttr)) {\n            rateLimiter = redisson.getRateLimiter(keyAttr);\n            // 设置RateLimiter的速率，每秒发放10个令牌\n            rateLimiter.trySetRate(RateType.OVERALL, blacklistInterceptor.rageLimit(), 1, RateIntervalUnit.SECONDS);\n            userRateLimiters.put(keyAttr, rateLimiter);\n        } else {\n            rateLimiter = userRateLimiters.getIfPresent(keyAttr);\n        }\n\n        // 限流拦截\n        if (rateLimiter != null && !rateLimiter.tryAcquire()) {\n            if (blacklistInterceptor.protectLimit() != 0) {\n                //封标识\n                blacklist.put(keyAttr, blacklist.getOrDefault(keyAttr, 0L) + 1L);\n                //封 IP\n                blacklist.put(remoteHost, blacklist.getOrDefault(remoteHost, 0L) + 1L);\n            }\n            log.info(\"你刷这么快干嘛黑子：{}\", keyAttr);\n            return fallbackMethodResult(jp, blacklistInterceptor.fallbackMethod());\n        }\n\n        // 返回结果\n        return jp.proceed();\n    }\n\n    private Object fallbackMethodResult(JoinPoint jp, String fallbackMethod) throws NoSuchMethodException, InvocationTargetException, IllegalAccessException {\n        Signature sig = jp.getSignature();\n        MethodSignature methodSignature = (MethodSignature) sig;\n        Method method = jp.getTarget().getClass().getMethod(fallbackMethod, methodSignature.getParameterTypes());\n        return method.invoke(jp.getThis(), jp.getArgs());\n    }\n\n    /**\n     * 实际根据自身业务调整，主要是为了获取通过某个值做拦截\n     */\n    public String getAttrValue(String attr, Object[] args) {\n        if (args[0] instanceof String) {\n            return args[0].toString();\n        }\n        String filedValue = null;\n        for (Object arg : args) {\n            try {\n                if (StringUtils.isNotBlank(filedValue)) {\n                    break;\n                }\n                filedValue = String.valueOf(this.getValueByName(arg, attr));\n            } catch (Exception e) {\n                log.error(\"获取路由属性值失败 attr：{}\", attr, e);\n            }\n        }\n        return filedValue;\n    }\n\n    /**\n     * 获取对象的特定属性值\n     *\n     * @param item 对象\n     * @param name 属性名\n     * @return 属性值\n     * @author tang\n     */\n    private Object getValueByName(Object item, String name) {\n        try {\n            Field field = getFieldByName(item, name);\n            if (field == null) {\n                return null;\n            }\n            field.setAccessible(true);\n            Object o = field.get(item);\n            field.setAccessible(false);\n            return o;\n        } catch (IllegalAccessException e) {\n            return null;\n        }\n    }\n\n    /**\n     * 根据名称获取方法，该方法同时兼顾继承类获取父类的属性\n     *\n     * @param item 对象\n     * @param name 属性名\n     * @return 该属性对应方法\n     * @author tang\n     */\n    private Field getFieldByName(Object item, String name) {\n        try {\n            Field field;\n            try {\n                field = item.getClass().getDeclaredField(name);\n            } catch (NoSuchFieldException e) {\n                field = item.getClass().getSuperclass().getDeclaredField(name);\n            }\n            return field;\n        } catch (NoSuchFieldException e) {\n            return null;\n        }\n    }\n\n\n}\n```\n\n这段代码主要实现了几个方面：\n\n- 获取限流对象的唯一标识。如用户 Id 或者其他。\n- 将标识来获取是否触发限流 + 黑名单 如果是这两种的一种，直接触发预先设置的回调（入参要跟原本接口一致喔）。\n- 通过反射来获取回调的属性以及方法名称，触发方法调用。\n- 封禁 标识 、IP 。\n\n## 代码测试\n\n\n![Snipaste_2024-05-23_12-13-13.png](https://pic.code-nav.cn/post_picture/1612254411675926529/DZ707YAF-Snipaste_2024-05-23_12-13-13.png)\n\n```java\n@BlacklistInterceptor(key = \"title\", fallbackMethod = \"loginErr\", rageLimit = 1L, protectLimit = 10)\n    @PostMapping(\"/login\")\n    public String login(@RequestBody UrlRelateAddRequest urlRelateAddRequest) {\n        log.info(\"模拟登录 title:{}\", urlRelateAddRequest.getTitle());\n        return \"模拟登录：登录成功 \" + urlRelateAddRequest.getTitle();\n    }\n\n    public String loginErr(UrlRelateAddRequest urlRelateAddRequest) {\n        return \"小黑子！你没有权限访问该接口！\";\n    }\n```\n\n- key：需要拦截的标识，用来判断请求对象。\n- fallbackMethod：回调的方法名称（这里需要注意的是入参要跟原本接口保持一致）。\n- rageLimit：每秒限制的访问次数。\n- protectLimit：超过每秒访问次数+1，当请求超过 protectLimit 值时，进入黑名单封禁 24 小时。\n\n以下是具体操作截图：\n\n\n![Snipaste_2024-05-23_11-28-41.png](https://pic.code-nav.cn/post_picture/1612254411675926529/pnQYgGLc-Snipaste_2024-05-23_11-28-41.png)\n\n到这里这个黑名单的拦截基本就实现啦，大家还有什么具体的补充点都可以提出来，一起学习一下，经过这次”恐吓风波“，让我知道互联网上的人戾气还是很重的，只要坚持好做自己，管他别人什么看法！！\n\n我是聪ζ希望可以跟大家一起学习，我的 Github：https://github.com/lhccong，如果里面有你感兴趣的项目不妨给我点个星星⭐和关注\uD83D\uDD25，未来我还会持续写新的好玩的小项目。\n\n\n\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1612254411675926529/6RZd2dGl-image-20240523081706355.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 59,
        "thumbNum": 11,
        "favourNum": 3,
        "commentNum": 2,
        "priority": 0,
        "userId": "1612254411675926529",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "editTime": "2024-05-23 13:55:37",
        "createTime": "2024-05-23 13:55:37",
        "updateTime": "2024-05-25 18:14:06",
        "accessScope": 0,
        "user": {
          "id": "1612254411675926529",
          "planetCode": "12852",
          "userName": "聪ζ",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg",
          "gender": 1,
          "userProfile": "一个喜欢捣鼓小玩意的小程序员",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/lhccong",
          "blog": "https://juejin.cn/user/1146154496301956/posts",
          "score": 0,
          "scoreLevel": 1,
          "coin": 0,
          "followeeNum": 5,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-08-21 21:17:54",
          "lastLoginTime": null,
          "createTime": "2023-01-09 09:06:20",
          "updateTime": "2024-05-23 16:29:20"
        },
        "tags": [
          "文章",
          "后端",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      },
      {
        "id": "1793309804359548930",
        "title": "假如你负责一个并发量很高的系统，现在出现了比较复杂的数据不一致问题？你认为会存在哪些可能？",
        "description": "假如你负责一个并发量很高的系统，现在出现了比较复杂的数据不一致问题？你认为会存在哪些可能？\n",
        "content": "整理一下昨天的题目：\n\n假如你负责一个并发量很高的系统，现在出现了比较复杂的数据不一致问题？你认为会存在哪些可能？\n\n只有在对一个数据在并发的进行读写的时候，才可能会出现这种问题。其实如果说你的并发量很低的话，特别是读并发很低，每天访问量就 1 万次，那么很少的情况下，会出现刚才描述的那种不一致的场景。\n但是问题是，如果每天的是上亿的流量，每秒并发读是几万，每秒只要有数据更新的请求，就可能会出现上述的数据库+缓存不一致的情况。\n\n**解决方案如下**：\n\n更新数据的时候，根据数据的唯一标识，将操作路由之后，发送到一个 jvm 内部队列中。读取数据的时候，如果发现数据不在缓存中，那么将重新执行“读取数据+更新缓存”的操作，根据唯一标识路由之后，也发送到同一个 jvm 内部队列中。\n一个队列对应一个工作线程，每个工作线程串行拿到对应的操作，然后一条一条的执行。这样的话，一个数据变更的操作，先删除缓存，然后再去更新数据库，但是还没完成更新。此时如果一个读请求过来，没有读到缓存，那么可以先将缓存更新的请求发送到队列中，此时会在队列中积压，然后同步等待缓存更新完成。\n这里有一个优化点，一个队列中，其实多个更新缓存请求串在一起是没意义的，因此可以做过滤，如果发现队列中已经有一个更新缓存的请求了，那么就不用再放个更新请求操作进去了，直接等待前面的更新操作请求完成即可。\n待那个队列对应的工作线程完成了上一个操作的数据库的修改之后，才会去执行下一个操作，也就是缓存更新的操作，此时会从数据库中读取最新的值，然后写入缓存中。\n如果请求还在等待时间范围内，不断轮询发现可以取到值了，那么就直接返回；如果请求等待的时间超过一定时长，那么这一次直接从数据库中读取当前的旧值。\n高并发的场景下，该解决方案要注意的问题：\n\n**读请求长时阻塞**\n\n由于读请求进行了非常轻度的异步化，所以一定要注意读超时的问题，每个读请求必须在超时时间范围内返回。\n该解决方案，最大的风险点在于说，可能数据更新很频繁，导致队列中积压了大量更新操作在里面，然后读请求会发生大量的超时，最后导致大量的请求直接走数据库。务必通过一些模拟真实的测试，看看更新数据的频率是怎样的。\n另外一点，因为一个队列中，可能会积压针对多个数据项的更新操作，因此需要根据自己的业务情况进行测试，可能需要部署多个服务，每个服务分摊一些数据的更新操作。如果一个内存队列里居然会挤压 100 个商品的库存修改操作，每个库存修改操作要耗费 10ms 去完成，那么最后一个商品的读请求，可能等待 10 * 100 = 1000ms = 1s 后，才能得到数据，这个时候就导致读请求的长时阻塞。\n一定要做根据实际业务系统的运行情况，去进行一些压力测试，和模拟线上环境，去看看最繁忙的时候，内存队列可能会挤压多少更新操作，可能会导致最后一个更新操作对应的读请求，会 hang 多少时间，如果读请求在 200ms 返回，如果你计算过后，哪怕是最繁忙的时候，积压 10 个更新操作，最多等待 200ms，那还可以的。\n如果一个内存队列中可能积压的更新操作特别多，那么你就要加机器，让每个机器上部署的服务实例处理更少的数据，那么每个内存队列中积压的更新操作就会越少。\n其实根据之前的项目经验，一般来说，数据的写频率是很低的，因此实际上正常来说，在队列中积压的更新操作应该是很少的。像这种针对读高并发、读缓存架构的项目，一般来说写请求是非常少的，每秒的 QPS 能到几百就不错了。\n我们来实际粗略测算一下。\n如果一秒有 500 的写操作，如果分成 5 个时间片，每 200ms 就 100 个写操作，放到 20 个内存队列中，每个内存队列，可能就积压 5 个写操作。每个写操作性能测试后，一般是在 20ms 左右就完成，那么针对每个内存队列的数据的读请求，也就最多 hang 一会儿，200ms 以内肯定能返回了。\n经过刚才简单的测算，我们知道，单机支撑的写 QPS 在几百是没问题的，如果写 QPS 扩大了 10 倍，那么就扩容机器，扩容 10 倍的机器，每个机器 20 个队列。\n读请求并发量过高\n这里还必须做好压力测试，确保恰巧碰上上述情况的时候，还有一个风险，就是突然间大量读请求会在几十毫秒的延时 hang 在服务上，看服务能不能扛的住，需要多少机器才能扛住最大的极限情况的峰值。\n但是因为并不是所有的数据都在同一时间更新，缓存也不会同一时间失效，所以每次可能也就是少数数据的缓存失效了，然后那些数据对应的读请求过来，并发量应该也不会特别大。\n\n**多服务实例部署的请求路由**\n\n可能这个服务部署了多个实例，那么必须保证说，执行数据更新操作，以及执行缓存更新操作的请求，都通过 Nginx 服务器路由到相同的服务实例上。\n比如说，对同一个商品的读写请求，全部路由到同一台机器上。可以自己去做服务间的按照某个请求参数的 hash 路由，也可以用 Nginx 的 hash 路由功能等等。\n\n**热点商品的路由问题，导致请求的倾斜**\n\n万一某个商品的读写请求特别高，全部打到相同的机器的相同的队列里面去了，可能会造成某台机器的压力过大。就是说，因为只有在商品数据更新的时候才会清空缓存，然后才会导致读写并发，所以其实要根据业务系统去看，如果更新频率不是太高的话，这个问题的影响并不是特别大，但是的确可能某些机器的负载会高一些。\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1627889630378479618/uYe6FLOm-181750LAK1m.jpg",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 13,
        "thumbNum": 4,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1627889630378479618",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "editTime": "2024-05-22 23:55:50",
        "createTime": "2024-05-22 23:55:50",
        "updateTime": "2024-05-24 22:39:11",
        "accessScope": 0,
        "user": {
          "id": "1627889630378479618",
          "planetCode": "2784",
          "userName": "答案说明所有",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1627889630378479618/FYBQxM7a-Screenshot_20230717_113840.jpg",
          "gender": 1,
          "userProfile": "目标大厂，冲冲冲！",
          "userRole": "vip",
          "interests": [],
          "place": "广东",
          "birthday": "2023-05-12",
          "school": "广东石油化工学院",
          "major": "数据科学与大数据技术",
          "education": null,
          "graduationYear": 2025,
          "jobStatus": "在校",
          "company": null,
          "job": null,
          "workYear": null,
          "direction": "大数据",
          "goal": "实习",
          "github": null,
          "blog": null,
          "score": 0,
          "scoreLevel": 1,
          "coin": 0,
          "followeeNum": 5,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2025-02-27 19:51:43",
          "lastLoginTime": null,
          "createTime": "2023-02-21 12:35:07",
          "updateTime": "2024-05-17 23:36:21"
        },
        "tags": [
          "文章",
          "系统设计",
          "后端"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      },
      {
        "id": "1792739563799298049",
        "title": "\uD83D\uDD25用好 explain 妈妈再也不用担心我的 SQL 慢了",
        "description": "大家好，我是聪，一个乐于分享的小小程序员。今天的聪碰见了一个当面试官的朋友问我，用过 explain 吗？说说怎么分析的？ 聪：一脸正经的回答道\uD83D\uDCA1",
        "content": "大家好，我是聪，一个乐于分享的小小程序员。在不久之前我写了一个慢 SQL 分析工具，可以用来分析 Java Mybatis 项目的 SQL 执行情况，其中刚好涉及到了 explain 的使用。感兴趣的可以了解一下。\n\nGithub 地址⭐：https://github.com/lhccong/sql-slow-mirror\n\n掘金文章分享\uD83D\uDCD1：https://juejin.cn/post/7358398963840548915\n\n那么开始我们今天的主题吧，今天的聪碰见了一个当面试官的朋友问我，用过 explain 吗？说说怎么分析的？\n\n<img src=\"https://pic.code-nav.cn/post_picture/1612254411675926529/sh3htrqy-image-20240423094124100.png\" alt=\"Snipaste_2024-04-24_11-30-56.png\" width=\"30%\" /></br>\n\n聪：一脸正经的回答道\uD83D\uDCA1\n\n聪：你好面试官，我当然用过 explain，我平时都会那它去查看 SQL 语句是否还能优化。接下来我从主要属性跟实际例子来讲解：\n\n### 主要的属性\n\n#### 1） \uD83C\uDF31 id\n\n查询中每个 SELECT 子句的标识符。简单查询的 id 通常为 1，复杂查询（如包含子查询或 UNION）的 id 会有多个。\n\n#### 2） \uD83C\uDF31 select_type\n\n描述查询的类型。比如：简单查询显示为 `SIMPLE`，子查询显示为 `SUBQUERY`，UNION 中的第二个和后续查询显示为 `UNION`。\n\n#### 3）\uD83C\uDF31 table\n\n表名称这个就不用再详细解释了吧哈哈。\n\n#### 4） \uD83C\uDF31 partitions\n\n表示查询涉及到的分区。如果你有使用分区表的话才需要关注此字段。\n\n#### 5） \uD83C\uDF31 type（重点记忆⭐）\n\n表示访问的类型，这里也可以看出你的 SQL 的性能。可能的值从最好到最差包括：`system`、`const`、`eq_ref`、`ref`、`range`、`index`、`ALL`。其中 `ALL` 表示全表扫描，效率最低。\n\n-   system：\n\n    表示查询的表只有一行（系统表）。这是一个特殊的情况，不常见。\n\n-   const：\n\n    表示查询的表最多只有一行匹配结果。这通常发生在查询条件是**主键**或**唯一索引**，并且是常量比较，以下是一个使用主键查找的例子：\n\n    ```sql\n    EXPLAIN SELECT * FROM employees WHERE employee_id = 12345;\n    ```\n\n-   eq_ref：\n\n    表示对于每个来自前一张表的行，MySQL 仅访问一次这个表。这通常发生在连接查询中使用主键或唯一索引的情况下，例子如下：\n\n    ```sql\n    EXPLAIN SELECT * FROM employees e JOIN departments d ON e.department_id = d.department_id;\n    ```\n\n-   ref：\n\n    MySQL 使用非唯一索引扫描来查找行。查询条件使用的索引是非唯一的（如普通索引），例子如下使用了非唯一索引进行查找：\n\n    ```sql\n    EXPLAIN SELECT * FROM employees WHERE department_id = 5;\n    ```\n\n-   range：表示 MySQL 会扫描表的一部分，而不是全部行。范围扫描通常出现在使用索引的范围查询中（如 `BETWEEN`、`>`, `<`, `>=`, `<=`）。下面是范围查询：\n\n    ```sql\n    EXPLAIN SELECT * FROM employees WHERE salary BETWEEN 50000 AND 100000;\n    ```\n\n-   index：表示 MySQL 扫描索引中的所有行，而不是表中的所有行。即使索引列的值覆盖查询，也需要扫描整个索引。以下是使用索引扫描例子：\n\n    ```sql\n    EXPLAIN SELECT name FROM employees;\n    ```\n\n-   all（性能最差）：表示 MySQL 需要扫描表中的所有行，即全表扫描。这通常出现在没有索引的查询条件中。以下是全表扫描例子：\n\n    ```sql\n    EXPLAIN SELECT * FROM employees;\n    ```\n\n#### 6） \uD83C\uDF31 possible_keys\n\n表示查询可能使用的索引列表。\n\n#### 7） \uD83C\uDF31 key\n\n实际使用索引。如果没有使用索引，该字段显示为 `NULL`。\n\n#### 8） \uD83C\uDF31 key_len\n\n这个字段表示使用的索引的长度。该值是根据索引的定义和查询条件计算的。\n\n#### 9） \uD83C\uDF31 rows\n\nMySQL 会估计为了找到所需的行，需要读取的行数。该值是一个估计值，不是精确值。\n\n#### 10）\uD83C\uDF31 filtered\n\n显示查询条件过滤掉的行的百分比。一个高百分比表示查询条件的选择性好。\n\n#### 11）\uD83C\uDF31 Extra\n\n额外信息，如 `Using index`（表示使用覆盖索引）、`Using where`（表示使用 WHERE 条件进行过滤）、`Using temporary`（表示使用临时表）、`Using filesort`（表示需要额外的排序步骤）。\n\n<p align=center><img src=\"https://pic.code-nav.cn/post_picture/1612254411675926529/bDDt3jAK-image-20240426101016819.png\" alt=\"12.jpg\" width=\"50%\" /></p>\n\n看完这个是不是一目了然了捏，那么接下来跟着我看看实际的分析例子吧！！\n\n### 实际例子\uD83C\uDF30\n\n#### 1.创建 employees 表\n\n```sql\nCREATE TABLE employees (\n    employee_id INT PRIMARY KEY,\n    first_name VARCHAR(50),\n    last_name VARCHAR(50),\n    department_id INT,\n    salary DECIMAL(10, 2),\n    hire_date DATE,\n    INDEX (department_id)\n);\n```\n\n我们要执行以下查询来查找部门 ID 为 5 且薪水在 50000 到 100000 之间的员工，并按薪水降序排序：\n\n```sql\nSELECT employee_id, first_name, last_name, salary\nFROM employees\nWHERE department_id = 5 AND salary BETWEEN 50000 AND 100000\nORDER BY salary DESC;\n```\n\n#### 2.我们先使用 explain 分析计划进行分析：\n\n```sql\nEXPLAIN SELECT employee_id, first_name, last_name, salary\nFROM employees\nWHERE department_id = 5 AND salary BETWEEN 50000 AND 100000\nORDER BY salary DESC;\n```\n\n输出结果如下：\n\n| id | select_type | table     | partitions | type | possible_keys | key           | key_len | ref   | rows | filtered | Extra                       |\n| -- | ----------- | --------- | ---------- | ---- | ------------- | ------------- | ------- | ----- | ---- | -------- | --------------------------- |\n| 1  | SIMPLE      | employees | NULL       | ref  | department_id | department_id | 4       | const | 5000 | 20.00    | Using where; Using filesort |\n\n#### 3.分析执行计划\n\n从执行计划中看出，`type` 为 `ref`，表示使用了 `department_id` 索引，这是个非唯一索引。`key` 为 `department_id` 这个索引，而且 `rows` 为 5000，表示扫描了 5000 行匹配的 `department_id = 5` 的条件。从 `Extra` 看出在应用 `WHERE` 条件后，还需要进行文件排序来满足 `ORDER BY` 子句。\n\n#### 4.找出问题\n\n尽管查询使用了索引，但由于索引不完全覆盖查询的条件和排序，查询需要进行额外的文件排序。这可能会导致性能瓶颈，特别是在结果集较大时。\n\n#### 5.优化解决它！\n\n**创建复合索引**\n\n创建一个包含 `department_id` 和 `salary` 的复合索引，这样可以覆盖查询的 `WHERE` 和 `ORDER BY` 条件：\n\n```sql\nCREATE INDEX idx_department_salary ON employees (department_id, salary);\n```\n\n复合索引可以使查询在扫描 `department_id` 列时，同时按 `salary` 列排序，避免额外的文件排序。\n\n**再次执行计划分析**\n\n优化后的 `EXPLAIN` 输出如下：\n\n| id | select_type | table     | partitions | type  | possible_keys         | key                   | key_len | ref  | rows | filtered | Extra       |\n| -- | ----------- | --------- | ---------- | ----- | --------------------- | --------------------- | ------- | ---- | ---- | -------- | ----------- |\n| 1  | SIMPLE      | employees | NULL       | range | idx_department_salary | idx_department_salary | 5       | NULL | 500  | 100.00   | Using where |\n\n#### 6.分析优化后的结果\n\n从新的 `EXPLAIN` 输出中可以看出：\n\n-   **type**: `range`，表示使用范围扫描，这是个相对高效的访问类型。\n-   **key**: `idx_department_salary`，表示实际使用了复合索引。\n-   **rows**: 500，估计读取的行数减少了，因为索引更精确地覆盖了查询条件。\n-   **Extra**: 仅显示 `Using where`，不再需要文件排序，因为索引已经覆盖了排序需求。\n\n\n<p align=center><img src=\"https://pic.code-nav.cn/post_picture/1612254411675926529/8nzDaRtW-image-20240423103604502.png\" alt=\"Snipaste_2024-04-23_11-09-44.png\" width=\"30%\" /></p>\n\n是不是分析起来很简单咧，完结撒花！！！！，除了新增联合索引的方式，你们还知道什么优化策略吗？\n",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1612254411675926529/9FaV18J6-image-20240423103604502.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 70,
        "thumbNum": 9,
        "favourNum": 0,
        "commentNum": 4,
        "priority": 0,
        "userId": "1612254411675926529",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "editTime": "2024-05-21 10:09:54",
        "createTime": "2024-05-21 10:09:54",
        "updateTime": "2024-05-25 16:21:21",
        "accessScope": 0,
        "user": {
          "id": "1612254411675926529",
          "planetCode": "12852",
          "userName": "聪ζ",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg",
          "gender": 1,
          "userProfile": "一个喜欢捣鼓小玩意的小程序员",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/lhccong",
          "blog": "https://juejin.cn/user/1146154496301956/posts",
          "score": 0,
          "scoreLevel": 1,
          "coin": 0,
          "followeeNum": 5,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-08-21 21:17:54",
          "lastLoginTime": null,
          "createTime": "2023-01-09 09:06:20",
          "updateTime": "2024-05-23 16:29:20"
        },
        "tags": [
          "文章",
          "数据库",
          "面试题",
          "面试"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      },
      {
        "id": "1792735479532863490",
        "title": "\uD83D\uDC96如何爱上写项目、写好项目，不妨看看我的做法",
        "description": "爱上写项目真的很简单！在大学期间的我，其实不能说不爱写项目，但是总是写出屎山代码、写出自己都不愿维护的代码。我写过很多项目包括尚硅谷的、黑马的、微信小程序的、接单的。但是这些项目都有一些共同点！",
        "content": "## 开篇\n\n爱上写项目真的很简单！在大学期间的我，其实不能说不爱写项目，但是总是写出屎山代码、写出自己都不愿维护的代码。我写过很多项目包括尚硅谷的、黑马的、微信小程序的、接单的。但是这些项目都有一些共同点！再次看它我不愿维护啊！当我项目越写越多，我会发现项目就像自己的孩子、自己的游戏角色，你要会打扮它，给它变强、变帅气，你才会越来越喜欢上它，就跟游戏一样，你也不喜欢你的游戏人物又丑又垃圾吧。\n\n## 拥有并打扮一下自己的 Github\n\n相信有很大部分人的 Github 是没有个人简介的、也没有头像。是个二维码头像，我以前也是这样，每次看见这个头像我都百感交集啊，我根本不想碰它。\n\n我一开始荒废的 Github 是这样的：\n\n\n![image-20240510092457155.png](https://pic.code-nav.cn/post_picture/1612254411675926529/lrCMjNpB-image-20240510092457155.png)\n\n经过我打扮的 Github （<https://github.com/lhccong>）：\n\n\n![image-20240510092548802.png](https://pic.code-nav.cn/post_picture/1612254411675926529/v5n4UjpA-image-20240510092548802.png)\n\n一个好的 Github 主页不仅能吸引面试官和小伙伴们的兴趣，还能提高自己的编程兴趣。每次看见自己的主页又能多一个项目、又多了 star 数、关注。心里对开发项目的兴趣又高了几分。\n\n关于主页如何打扮，只需要创建一个跟自己名字一样的仓库，里面写一个 README.md 就可以显示在主页啦！是不是十分简单又便捷，至于具体的样式可以参考市面上优秀的作者：程序员鱼皮（鱼总\uD83D\uDC1F）直接 Copy 完事 随便改改参数。\n\n## 给新项目取个好名字、搞个好图标\n\n像我写项目有个习惯，我不喜欢一上来就开始写项目，我喜欢先配合 GPT 给我的项目取个好听的名字\uD83D\uDD25，我经常是这样干的，比如说我的微狗、短链狗、SQL 慢镜 也是有问过 GPT 的意见。\n\n至于好图标，我是通过鱼聪明（<https://www.yucongming.com/app/draw>）生成的，之前白嫖到的鱼毛来进行图标生成，给大家看看我的几个图标吧。\n\n<p align=center><img src=\"https://pic.code-nav.cn/post_picture/1612254411675926529/MjV0y3Cv-image-20240510093634316.png\" alt=\"image-20240510093709272.png\"  /></p>\n\n<p align=center><img src=\"https://pic.code-nav.cn/post_picture/1612254411675926529/sJwfuKIW-image-20240510093709272.png\" alt=\"image-20240510093709272.png\"  /></p>\n\n\n好的图标能让别人更加的对你的项目好奇，也会提高你自己的兴趣喔。\n\n## 将大提交改成小提交\n\n这句话是什么意思呢，之前的我是每次写完一大堆代码，再一次性提交上去。这样的写法会导致项目十分难以维护，你根本都不知道自己一大段提交做了什么，到后面你自己的代码就不想看了，我的做法是什么呢？我将每次的小功能、小代码都弄成一次提交，最后统一的进行 push ，这样当你自己或者别人查看你的代码时，都会清楚明白你这次改动做了什么。举个例子：就好像我前段时间学习的 yu-rpc，我自己的提交就有一百多次。\n\n\n\n![image-20240510094446449.png](https://pic.code-nav.cn/post_picture/1612254411675926529/12dQukZf-image-20240510094446449.png)\n\n我经常用的提交格式： 新增功能时用 feat 、 修改代码时用 fix 、修改、新增文档时用 docs\n\n## 给代码穿好衣服\n\n相信大家也是很讨厌写注释，但是写注释不仅能让别人能懂你的代码，更重要是自己在阅读代码的时候能更好的快速回顾自己的代码是干了什么，能帮助自己快速的维护，现在都是 AI 时代，我自己写代码的时候对于普通的代码我都会使用 AI（CodeGeex）来进行注释生成、比较特殊的代码我会自己进行注释修改。\n\n\n\n![image-20240510095442156.png](https://pic.code-nav.cn/post_picture/1612254411675926529/8CCL9pBe-image-20240510095442156.png)\n\n## 不要忽略提交预警\n\n相信大家在提交的时候会看见自己的代码有很多黄色波浪线、提交的时候还会弹出框来预警：\n\n\n![image-20240510095626960.png](https://pic.code-nav.cn/post_picture/1612254411675926529/wBmT9Oee-image-20240510095626960.png)\n\n我推荐大家先尝试将这些预警修复，每当我看见一个项目有十分多黄色波浪线时，我的代码强迫症就会出现（现实我是没有强迫症的），现在的我总喜欢一个一个将黄色修复，这样下次写起来也会让自己的代码更加规范、更加美观。\n\n## 不妨写个好看的 README.md\n\n一个好看的项目介绍文档能吸引别人注意力、能让人家更想了解你的项目。可以参考别人开源项目的 README.md 直接 Copy！稍作修改就能成为自己项目的介绍啦~大家可以赶快去上手试一下，在介绍中可以加入自己的项目截图、项目技术栈喔，附上我的一个项目介绍：\n\n\n\n<p align=center><img src=\"https://pic.code-nav.cn/post_picture/1612254411675926529/mwbcbxiL-image-20240510100116317.png\" alt=\"image-20240510100116317.png\"  /></p>\n\n## 学习好项目\n\n我现在比较喜欢学习别人的优秀项目，比如 Sa-Token 、MyBatis、JustAuth ，参考着市面上的开源项目我也写出了：\n\n1）SQL 慢镜：<https://github.com/lhccong/sql-slow-mirror>\n\n2）OneAuth：<https://github.com/lhccong/OneAuth>\n\n3）Switch-HTTP：<https://github.com/lhccong/switch-http>\n\n4）AsyncX：<https://github.com/lhccong/AsyncX>\n\n觉得写的还不错的代码可以给我一个免费的小星星⭐⭐喔\n\n那这些项目都从哪发现的呢？我有以下几个渠道：\n\n1）直接 Github 上搜索 Java 项目高 Star 的开源项目。\n\n2）在 Gitee 上有一个 GVP 项目，最有价值开源项目选择 Java 类型的来学习。\n\n3）查看技术博主推的一些开源学习项目。\n\n## 坚持自己的知识输出\n\n当我每次发帖子都会发现，我不仅分享了知识，我还加深了自己对知识的理解，对于知识的加深更加提高了我对代码的喜欢，我喜欢在星球上分享自己学习到的知识、在掘金、CSDN 有时也会一起分享，看到大家给我点赞也能满足自己的一点小小虚荣心吧哈哈哈。\n\n给大家分享下我的掘金跟 CSDN\n\n掘金\uD83D\uDEEB：<https://juejin.cn/user/1146154496301956/posts>\n\nCSDN\uD83D\uDD25：<https://blog.csdn.net/LHCong>_\n\n以上就是我的分享啦~感谢大家看到最后，我是聪ζ希望可以跟大家一起学习，我的 Github：<https://github.com/lhccong>，如果里面有你感兴趣的项目不妨给我点个星星⭐和关注\uD83D\uDD25，未来我还会持续写新的好玩的小项目。",
        "category": "文章",
        "cover": "https://pic.code-nav.cn/post_cover/1612254411675926529/rK8VWC4w-image-20240510092548802.png",
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 65,
        "thumbNum": 11,
        "favourNum": 4,
        "commentNum": 0,
        "priority": 0,
        "userId": "1612254411675926529",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "editTime": "2024-05-21 09:53:40",
        "createTime": "2024-05-21 09:53:40",
        "updateTime": "2024-05-25 16:47:43",
        "accessScope": 0,
        "user": {
          "id": "1612254411675926529",
          "planetCode": "12852",
          "userName": "聪ζ",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1612254411675926529/JbN5T832-1.jpg",
          "gender": 1,
          "userProfile": "一个喜欢捣鼓小玩意的小程序员",
          "userRole": "vip",
          "interests": [],
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": "本科",
          "graduationYear": 2023,
          "jobStatus": "已工作",
          "company": null,
          "job": "后端",
          "workYear": null,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/lhccong",
          "blog": "https://juejin.cn/user/1146154496301956/posts",
          "score": 0,
          "scoreLevel": 1,
          "coin": 0,
          "followeeNum": 5,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": "2024-08-21 21:17:54",
          "lastLoginTime": null,
          "createTime": "2023-01-09 09:06:20",
          "updateTime": "2024-05-23 16:29:20"
        },
        "tags": [
          "文章",
          "GitHub",
          "后端",
          "开源",
          "Java"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      },
      {
        "id": "1792496988945367042",
        "title": "法拉第未来一夜暴涨 367%，贾跃亭回国有望了？",
        "description": null,
        "content": "贾跃亭做个人ip，这是要模仿罗永浩的“真还传”？\n\n法拉第未来（FF）、乐视创始人贾跃亭前不久刚跳出来表示要做个人 IP，5 月 14 号，美股法拉第未来就出现股价异常波动，开盘暴涨190%，**截至当日收盘，报收0.285美元/股，涨367.21%，涨幅居全美股第二**。\n\n要知道，法拉第未来之前才收到纳斯达克的退市警告，贾跃亭这次打出的旗号，就是想当”网红“还债救 FF。\n\n虽然当天就被法拉第未来在官网上无情撇清关系，表示这只是贾跃亭的个人行为，但贾老板的个人视频已经发起来了。\n\n### 贾跃亭其人\n\n股市的风波可以让子弹再飞一会。\n\n以防有些年轻的朋友对这个名字感到陌生，趁此机会，我们搜集了各路相关信息，以简历的方式带大家回顾一下贾跃亭的职业生涯。\n\n> 完整简历在线查看：https://laoyujianli.com/open/resume/jiayueting?type=1\n\n![点击阅读原文查看完整版贾跃亭简历](https://pic.yupi.icu/yuyi/%E8%B4%BE%E8%B7%83%E4%BA%AD%E7%AE%80%E5%8E%86%E8%A3%81%E5%89%AA%E7%89%88.png)\n\n\n\n### 当网红，真是为了 FF？\n\n关于个人 IP 商业化，贾总还真不是说说而已。\n\n截止目前，贾跃亭个人名字开通的视频号已发布 4 条视频，其中最新一条拍摄了自己的工作日常，并喊话“成长吧！奋斗者”。\n\n与此同时，另一位深谙流量之道的互联网活跃分子孙宇晨发视频称，愿意投资贾跃亭的个人 IP 商业化项目，还表示自己以前的创业受到很多贾跃亭思想的影响。\n\n尽管贾跃亭说得非常好听：“自己想做的不是简单的直播带货，而是通过模式创新、AI 技术创新，IP电商全球化，中国品牌出海等几个维度来探索一条IP电商2.0的新路径，希望自己的失败经历让大家少踩坑，多成长。“\n\n但网友们还是犀利指出，怕不是看到雷军和周鸿祎的流量眼红了，也想分一杯羹。打出了“为救 FF“的旗号，当网红赚钱还债，这套路走得还是罗永浩的老路。\n\n对于贾跃亭的这番新动作，你怎么看？\n\n----\n\n\n\n可访问我的 Github：https://github.com/liyupi ，了解更多技术和项目内容。",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 25,
        "thumbNum": 6,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1601072287388278786",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": null,
        "reviewTime": null,
        "editTime": "2024-05-20 18:05:59",
        "createTime": "2024-05-20 18:05:59",
        "updateTime": "2024-05-25 15:44:49",
        "accessScope": 0,
        "user": {
          "id": "1601072287388278786",
          "planetCode": "1",
          "userName": "程序员鱼皮",
          "userAvatar": "https://pic.code-nav.cn/user_avatar/1601072287388278786/9vqTr3HM-WechatIMG1287.jpeg",
          "gender": 1,
          "userProfile": "这个网站的老大",
          "userRole": "admin",
          "interests": [
            "C++",
            "Java",
            "Python",
            "算法"
          ],
          "place": "上海",
          "birthday": "1998-11-03",
          "school": "东华大学",
          "major": "网络工程",
          "education": null,
          "graduationYear": 2020,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": 2,
          "direction": "后端",
          "goal": null,
          "github": "https://github.com/liyupi",
          "blog": "https://yupi.icu",
          "score": 3345,
          "scoreLevel": 7,
          "coin": 170,
          "followeeNum": 1568,
          "followNum": 6,
          "followStatus": null,
          "vipExpireTime": "2287-05-20 01:46:39",
          "lastLoginTime": null,
          "createTime": "2022-12-09 12:32:33",
          "updateTime": "2024-05-25 16:14:58"
        },
        "tags": [
          "文章",
          "简历"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      },
      {
        "id": "1792193343515373570",
        "title": "有没有哪些小厂还在招实习呀",
        "description": "本人25届，非常愁实习，大厂肯定无望，只想暑假找到个实习有个经验",
        "content": "本人25届，非常愁实习，大厂肯定无望，只想暑假找到个实习有个经验",
        "category": "文章",
        "cover": null,
        "language": null,
        "externalLink": null,
        "shortLink": null,
        "componentName": null,
        "viewNum": 21,
        "thumbNum": 2,
        "favourNum": 0,
        "commentNum": 0,
        "priority": 0,
        "userId": "1792193084991057921",
        "reviewStatus": 1,
        "reviewMessage": null,
        "reviewerId": "1601072287388278786",
        "reviewTime": "2024-05-21 19:00:13",
        "editTime": "2024-05-20 17:04:20",
        "createTime": "2024-05-19 21:59:25",
        "updateTime": "2024-05-25 15:45:12",
        "accessScope": 0,
        "user": {
          "id": "1792193084991057921",
          "planetCode": null,
          "userName": "\uD83E\uDD5F",
          "userAvatar": "https://thirdwx.qlogo.cn/mmopen/vi_32/PiajxSqBRaEI3EldP4TQicjn2jLickDMQfKpJqNLKqMfVvvnwrbjR7cnLsU6GbSaRCTicic9ib7mVH78GbG3BBak6qiapIN1CuZiazVaicTI1Usu4FiaeBKD4r6f4pUA/132",
          "gender": null,
          "userProfile": null,
          "userRole": "user",
          "interests": null,
          "place": null,
          "birthday": null,
          "school": null,
          "major": null,
          "education": null,
          "graduationYear": null,
          "jobStatus": null,
          "company": null,
          "job": null,
          "workYear": null,
          "direction": null,
          "goal": null,
          "github": null,
          "blog": null,
          "score": 0,
          "scoreLevel": 1,
          "coin": 0,
          "followeeNum": 0,
          "followNum": 0,
          "followStatus": null,
          "vipExpireTime": null,
          "lastLoginTime": null,
          "createTime": "2024-05-19 21:58:23",
          "updateTime": "2024-05-19 21:58:23"
        },
        "tags": [
          "文章"
        ],
        "fileList": null,
        "videoList": [],
        "atUserList": null,
        "pictureList": null,
        "hasThumb": false,
        "hasFavour": false,
        "needVip": null,
        "atUserVOList": null,
        "status": null,
        "relatedLink": null,
        "acceptAnswerId": null
      }
    ],
    "total": "4369",
    "size": "8",
    "current": "1",
    "orders": [],
    "optimizeCountSql": true,
    "searchCount": true,
    "countId": null,
    "maxLimit": null,
    "pages": "547"
  },
  "message": "ok"
}